From e5b2370823904668708a11954c67e068a1b0479d Mon Sep 17 00:00:00 2001
From: Laine Stump <laine@laine.org>
Date: Fri, 13 Mar 2015 15:29:01 -0400
Subject: [PATCH 05/13] check for valid pointer on all returns from aug_get()

Part of resolution for:

  https://bugzilla.redhat.com/show_bug.cgi?id=1165966
  (CVE-2014-8119)

Several calls to aug_get() assumed that if the return value wasn't <0,
that it was returning a valid pointer to a string. Aside from the fact
that a return of 0 indicates no string, there is also the problem that
even if the return value is 1, the string could be NULL.

In most cases this didn't cause a problem in practice, because the
path being sent to aug_get() was a path previously returned by
aug_match() (implying that it really does point to a value).
(cherry picked from commit d8146041b5b969d709da4433fead262b51a397d7)
---
 src/drv_debian.c |    6 +++---
 src/drv_redhat.c |   10 +++++-----
 src/drv_suse.c   |    6 +++---
 3 files changed, 11 insertions(+), 11 deletions(-)

diff --git a/src/drv_debian.c b/src/drv_debian.c
index 64160e7..ba13819 100644
--- a/src/drv_debian.c
+++ b/src/drv_debian.c
@@ -156,7 +156,7 @@ static int interface_deps(struct netcf *ncf, char ***slaves, const char *fmt, ..
         r = aug_get(aug, matches[i], &devs);
         ERR_COND_BAIL(r < 0, ncf, EOTHER);
 
-        if (strcmp(devs, "none") == 0)
+        if (r != 1 || !devs || STREQ(devs, "none"))
             continue;
 
         do {
@@ -288,7 +288,7 @@ static int uniq_device_names(struct netcf *ncf,
     for (int i=0; i < ndevs; i++) {
         const char *name = NULL;
         r = aug_get(aug, devs[i], &name);
-        ERR_COND_BAIL(r != 1, ncf, EOTHER);
+        ERR_COND_BAIL(r != 1 || !name, ncf, EOTHER);
         int exists = 0;
         for (int j = 0; j < ndevnames; j++)
             if (STREQ(name, devnames[j])) {
@@ -528,7 +528,7 @@ static int aug_get_xml_for_intf(struct netcf *ncf,
             xmlNewProp(node, BAD_CAST "label",
                        BAD_CAST matches[j] + strlen(intf[i]) + 1);
             r = aug_get(aug, matches[j], &value);
-            ERR_COND_BAIL(r < 0, ncf, EOTHER);
+            ERR_COND_BAIL(r != 1 || !value, ncf, EOTHER);
             xmlNewProp(node, BAD_CAST "value", BAD_CAST value);
         }
 
diff --git a/src/drv_redhat.c b/src/drv_redhat.c
index a90eeb6..e1ca76f 100644
--- a/src/drv_redhat.c
+++ b/src/drv_redhat.c
@@ -148,7 +148,7 @@ static char *find_ifcfg_path_by_hwaddr(struct netcf *ncf, const char *mac) {
     for (int i=0; i < nhwaddr; i++) {
         const char *addr;
         r = aug_get(aug, hwaddr[i], &addr);
-        ERR_COND_BAIL(r != 1, ncf, EOTHER);
+        ERR_COND_BAIL(r != 1 || !addr, ncf, EOTHER);
         if (STRCASEEQ(addr, mac))
             match = i;
     }
@@ -257,7 +257,7 @@ static int uniq_ifcfg_paths(struct netcf *ncf,
     for (int i=0; i < ndevs; i++) {
         const char *name = NULL;
         r = aug_get(aug, devs[i], &name);
-        ERR_COND_BAIL(r != 1, ncf, EOTHER);
+        ERR_COND_BAIL(r != 1 || !name, ncf, EOTHER);
         int exists = 0;
         for (int j = 0; j < ndevnames; j++)
             if (STREQ(name, devnames[j])) {
@@ -414,7 +414,7 @@ static int list_interface_ids(struct netcf *ncf,
                                 == (NETCF_IFACE_ACTIVE|NETCF_IFACE_INACTIVE));
 
             r = aug_get(aug, matches[nmatches-1], &name);
-            ERR_COND_BAIL(r < 0, ncf, EOTHER);
+            ERR_COND_BAIL(r != 1 || !name, ncf, EOTHER);
 
             if (!is_qualified) {
                 int is_active = if_is_active(ncf, name);
@@ -507,7 +507,7 @@ static xmlDocPtr aug_get_xml(struct netcf *ncf, int nint, char **intf) {
             xmlNewProp(node, BAD_CAST "label",
                        BAD_CAST matches[j] + strlen(intf[i]) + 1);
             r = aug_get(aug, matches[j], &value);
-            ERR_COND_BAIL(r < 0, ncf, EOTHER);
+            ERR_COND_BAIL(r != 1 || !value, ncf, EOTHER);
             xmlNewProp(node, BAD_CAST "value", BAD_CAST value);
         }
         free_matches(nmatches, &matches);
@@ -748,7 +748,7 @@ static int bridge_slaves(struct netcf *ncf, const char *name, char ***slaves) {
         char *p = (*slaves)[i];
         const char *dev;
         r = aug_get(aug, p, &dev);
-        ERR_COND_BAIL(r < 0, ncf, EOTHER);
+        ERR_COND_BAIL(r != 1 || !dev, ncf, EOTHER);
 
         (*slaves)[i] = strdup(dev);
         free(p);
diff --git a/src/drv_suse.c b/src/drv_suse.c
index a99b134..3b1ebd1 100644
--- a/src/drv_suse.c
+++ b/src/drv_suse.c
@@ -503,7 +503,7 @@ static xmlDocPtr aug_get_xml(struct netcf_if *nif, int nint, char **intf) {
             xmlNewProp(node, BAD_CAST "label",
                        BAD_CAST matches[j] + pathoffset + strlen(intf[i]) + 1);
             r = aug_get(aug, matches[j], &value);
-            ERR_COND_BAIL(r < 0, ncf, EOTHER);
+            ERR_COND_BAIL(r != 1 || !value, ncf, EOTHER);
             xmlNewProp(node, BAD_CAST "value", BAD_CAST value);
         }
         {
@@ -514,7 +514,7 @@ static xmlDocPtr aug_get_xml(struct netcf_if *nif, int nint, char **intf) {
         }
         {
             const char *mac = NULL;
-            if( find_hwaddr_by_device(ncf, nif->name, &mac) > 0 ) {
+            if(find_hwaddr_by_device(ncf, nif->name, &mac) > 0 && mac) {
                 xmlNodePtr node = xmlNewChild(tree, NULL, BAD_CAST "node", NULL);
                 xmlNewProp(node, BAD_CAST "label",
                            BAD_CAST "HWADDR" );
@@ -890,7 +890,7 @@ static int bridge_slaves(struct netcf *ncf, const char *name, char ***slaves) {
         char *p = (*slaves)[i];
         const char *dev;
         r = aug_get(aug, p, &dev);
-        ERR_COND_BAIL(r < 0, ncf, EOTHER);
+        ERR_COND_BAIL(r != 1 || !dev, ncf, EOTHER);
 
         (*slaves)[i] = strdup(dev);
         free(p);
-- 
1.7.1

